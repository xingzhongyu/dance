# Configuration for function minimization example
max_iterations: 5 #50
checkpoint_interval: 5

# LLM configuration
llm:
  primary_model: "deepseek-reasoner" #"deepseek-reasoner"
  # primary_model: "llama3.1-8b"
  primary_model_weight: 0.8
  secondary_model: "deepseek-reasoner" #"deepseek-reasoner"
  # secondary_model: "llama-4-scout-17b-16e-instruct"
  secondary_model_weight: 0.2
  api_base: "https://api.deepseek.com"
  # api_base: "https://api.cerebras.ai/v1"
  temperature: 0.7
  max_tokens: 8192
  timeout: 1200

# Prompt configuration
prompt:
  system_message: "
            ### Agent Prompt for Improving Louvain Graph Construction

            You are an expert programmer specializing in computational biology and graph-based methods for single-cell and spatial transcriptomics data analysis.

            Your task is to significantly improve a preprocessing script that constructs a cell-cell neighborhood graph for the Louvain community detection algorithm. The primary goal is to enhance the graph structure to produce more biologically meaningful and spatially coherent clusters.

            The script uses Scanpy to build the graph. The core of the preprocessing is the `NeighborGraph` class, which wraps `scanpy.pp.neighbors`. Your modifications should focus on this class to create a graph that better represents both the transcriptional and spatial relationships between cells.

            ---

            ### Context: The Louvain Algorithm

            To make informed improvements, you must understand the downstream algorithm:

            1.  **Core Function:** The Louvain algorithm is a classic, greedy method for community detection in large networks. Its goal is to find clusters (communities) of nodes by optimizing a quality function called **modularity**.
            2.  **Modularity:** High modularity indicates a graph where nodes within communities are much more densely connected to each other than to nodes outside their community.
            3.  **Input:** The algorithm operates on a **weighted, undirected graph** represented by an adjacency matrix (in this case, the `connectivities` matrix generated by `scanpy.pp.neighbors`).
            4.  **Critical Dependency:** The algorithm's performance is **entirely dependent on the quality of this input graph**. It has no knowledge of the original gene expression data or the spatial coordinates. All biological and spatial context must be encoded into the graph's structure (its edges and edge weights) *before* the algorithm is run. A better graph directly leads to better clusters.

            ---

            ### Potential Improvement Strategies

            Focus your improvements on the `NeighborGraph` class. You are encouraged to combine these strategies or develop your own novel approaches.

            **1. Spatially-Aware Graph Construction (Most Critical):**
            *   The current graph is built only in a feature space (e.g., PCA), completely ignoring the cells' physical locations. For spatial data, this is a major missed opportunity.
                *   **Action:** Modify the preprocessor to generate a graph that integrates **both** transcriptional similarity and spatial proximity.
                *   **Method 1 (Intersection/Union):** Build two separate graphs: one based on PCA features (as is done now) and another based on spatial coordinates (`adata.obsm['spatial']`). Then, combine them. For example, the final adjacency matrix could be a weighted sum (`alpha * A_pca + (1-alpha) * A_spatial`) or an intersection (an edge exists only if cells are neighbors in both PCA and spatial space).
                *   **Method 2 (Specialized Library):** Replace the generic `scanpy.pp.neighbors` with a function from a library designed for spatial analysis, like **`squidpy`**. The `squidpy.gr.spatial_neighbors` function is the ideal tool. It can build a neighborhood graph directly from spatial coordinates and can weight edges by distance.

            **2. Refine the Feature Space for Graph Building:**
            *   The graph's quality depends heavily on the features used to define 'similarity.'
                *   **Spatially-Informed Features:** Instead of standard PCA, use features that already incorporate spatial information. One could first run a method like `squidpy.tl.spatial_autocorrelation` to find spatially variable genes (SVGs) and then run PCA *only on those genes*. This ensures the feature space used for k-NN is enriched for spatially relevant signals.
                *   **Alternative Metrics:** The default `metric='euclidean'` is good for PCA space, but if you build a graph directly on high-dimensional gene expression, `metric='cosine'` is often more robust.

            **3. Advanced Graph Construction Parameters:**
            *   The current implementation uses default parameters from `scanpy.pp.neighbors`. These can be tuned for better results.
                *   **k-NN vs. Radius Graph:** The current method uses a fixed number of neighbors (`knn=True`). In tissues with varying cell density, a **radius-based graph** can be more effective. `squidpy.gr.spatial_neighbors` supports this directly, connecting all cells within a certain physical distance.
                *   **Graph Pruning:** After constructing a graph, consider pruning it to remove low-confidence edges. For example, remove edges with a weight below a certain threshold. This can denoise the graph and lead to cleaner communities from Louvain.

            **4. Leverage the Power of `squidpy`:**
            *   `squidpy` is the state-of-the-art library for spatial transcriptomics analysis in Python and is built on top of Scanpy. A complete and powerful solution would be to refactor `NeighborGraph` to be a wrapper for `squidpy`'s graph construction tools.
                *   **Proposed Workflow:**
                    1.  Inside `__call__`, use `squidpy.gr.spatial_neighbors` to create a spatial graph stored in `adata.obsp['spatial_connectivities']`.
                    2.  Optionally, keep the original `sc.pp.neighbors` call to get the transcriptional graph (`adata.obsp['connectivities']`).
                    3.  Combine these two adjacency matrices into a final graph for Louvain. Store this final graph in `data.data.obsp[self.out]`.

            **Constraints:**
            Do not change the `Louvain` class, the main training loop, or the final evaluation output format. Your modifications must be confined to the `NeighborGraph` data preprocessing class to improve the quality of the adjacency matrix it produces.
            "
  
  include_artifacts: true
  max_artifact_bytes: 32768
  artifact_security_filter: true

# Database configuration
database:
  population_size: 50
  archive_size: 20
  num_islands: 3
  elite_selection_ratio: 0.2
  exploitation_ratio: 0.7

# Evaluator configuration
evaluator:
  timeout: 600000
  cascade_thresholds: [0.3]
  parallel_evaluations: 3

# Evolution settings
diff_based_evolution: true
max_code_length: 20000